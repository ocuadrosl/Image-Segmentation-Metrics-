/*
 * OCE.h
 *
 *  Created on: 13/2/2015
 *      Author: oscar
 */

#include <vector>
#include <cmath>
#include "SEG.h"
#include "Metric.h"

using namespace std;

#ifndef OCE_H_
#define OCE_H_

typedef vector<vector<int> > reg_t; //seg row

/*
 *  An evaluation metric for image segmentation of multiple objects
 *	Mark Polak - 2009
 *	Implementation: Oscar
 *
 * */

class OCE: public Metric
{
	public:
		float operator()(SEG* __seg_1, SEG* __seg_2);

	private:

		int bar_delta(int __input); //bar delta: see the paper (equation 6)
		float w_ji(reg_t __reg_i, reg_t __reg_j); //equation 6

};

float OCE::w_ji(reg_t __reg_i, reg_t __reg_j)
{

	float num = bar_delta(I(__reg_j, __reg_i)) * size(__reg_i);

	float den = 0;

	//for(un) todo falta ver eso de la k

	return num / den;

}

int OCE::bar_delta(int __input)
{
	return (__input == 0) ? 0 : 1;

}

float OCE::operator()(SEG* __seg_1, SEG* __seg_2)
{

	cout << I((*__seg_1)[0], (*__seg_2)[1]) << endl;

	float error = 0;

	for (int j = 0; j < __seg_1->size(); j++)
	{

		float jacc = 0;
		for (int i = 0; i < __seg_2->size(); i++)
		{

			float den = 0;
			float num = 0;

			for (int k = 0; k < __seg_2->size(); k++)
			{
				den += bar_delta(I((*__seg_1)[j], (*__seg_2)[k])) * size((*__seg_2)[k]);
			}

			num = bar_delta(I((*__seg_1)[j], (*__seg_2)[i])) * size((*__seg_2)[i]);

			float w_ij = num / den;

			jacc += (jaccard((*__seg_1)[j], (*__seg_2)[i]) * w_ij);

		}

		jacc = 1 - jacc;

		float den = 0;
		for (int k = 0; k < __seg_2->size(); k++)
		{
			den += size((*__seg_1)[k]);
		}

		float w_j = size((*__seg_1)[j]) / den;

		error = error + (jacc * w_j);

	}

	return error;
}

#endif /* OCE_H_ */
